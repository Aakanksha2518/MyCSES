name: Enhanced PR Automation

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]
  issues:
    types: [opened]

permissions:
  issues: write
  pull-requests: write
  contents: read
  repository-projects: read

jobs:
  auto-label-and-message:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Enhanced PR Labeling and Messaging
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.pull_request.number;
          const prTitle = context.payload.pull_request.title.toLowerCase();
          const prBody = context.payload.pull_request.body || '';
          const prBodyLower = prBody.toLowerCase();
          const author = context.payload.pull_request.user.login;
          
          console.log(`üîç Processing PR #${prNumber} by ${author}`);
          console.log(`üìù Title: ${context.payload.pull_request.title}`);
          
          // Get changed files to determine category
          const { data: files } = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: prNumber
          });
          
          console.log(`üìÇ Changed files: ${files.map(f => f.filename).join(', ')}`);
          
          // Initialize labels array
          const labelsToAdd = ['hacktoberfest'];
          
          // Add current year Hacktoberfest label during October
          const now = new Date();
          const currentMonth = now.getMonth() + 1;
          const currentYear = now.getFullYear();
          
          if (currentMonth === 10) {
            labelsToAdd.push(`hacktoberfest_${currentYear}`);
          }
          
          // Analyze changed files to determine category and type
          const changedFiles = files.map(f => f.filename);
          let categoryDetected = false;
          
          for (const filename of changedFiles) {
            // Category detection based on file path
            if (filename.includes('1_introductory') || filename.includes('introductory')) {
              labelsToAdd.push('category: introductory');
              labelsToAdd.push('good first issue');
              categoryDetected = true;
            } else if (filename.includes('2_sorting_searching') || filename.includes('sorting') || filename.includes('searching')) {
              labelsToAdd.push('category: sorting-searching');
              categoryDetected = true;
            } else if (filename.includes('3_dp') || filename.includes('dynamic')) {
              labelsToAdd.push('category: dp');
              categoryDetected = true;
            } else if (filename.includes('5_range_queries') || filename.includes('range')) {
              labelsToAdd.push('category: range-queries');
              categoryDetected = true;
            } else if (filename.includes('7_mathematics') || filename.includes('math')) {
              labelsToAdd.push('category: mathematics');
              categoryDetected = true;
            }
          }
          
          // Analyze PR content for type and difficulty
          const combinedText = prTitle + ' ' + prBodyLower;
          
          // Type detection
          if (combinedText.includes('fix') || combinedText.includes('bug') || combinedText.includes('correct')) {
            labelsToAdd.push('bug');
          } else if (combinedText.includes('add') || combinedText.includes('new') || combinedText.includes('solution')) {
            labelsToAdd.push('enhancement');
          } else if (combinedText.includes('doc') || combinedText.includes('readme') || combinedText.includes('comment')) {
            labelsToAdd.push('documentation');
          }
          
          // Difficulty detection
          if (combinedText.includes('easy') || combinedText.includes('simple') || combinedText.includes('basic')) {
            labelsToAdd.push('easy');
            if (!labelsToAdd.includes('good first issue')) {
              labelsToAdd.push('good first issue');
            }
          } else if (combinedText.includes('hard') || combinedText.includes('difficult') || combinedText.includes('complex')) {
            labelsToAdd.push('hard');
            labelsToAdd.push('help wanted');
          } else if (combinedText.includes('medium') || combinedText.includes('intermediate')) {
            labelsToAdd.push('medium');
          }
          
          // Remove duplicates
          const uniqueLabels = [...new Set(labelsToAdd)];
          
          // Apply labels
          try {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: uniqueLabels
            });
            
            console.log(`‚úÖ Added labels: ${uniqueLabels.join(', ')}`);
          } catch (error) {
            console.error('‚ùå Error adding labels:', error);
          }
          
          // Check if PR body is properly filled using template
          const hasProperDescription = prBody.includes('Problem Name') && 
                                     prBody.includes('Solution Approach') && 
                                     prBody.length > 200;
          
          // Check if this is user's first contribution
          const { data: userPRs } = await github.rest.pulls.list({
            owner,
            repo,
            creator: author,
            state: 'all'
          });
          
          const isFirstContribution = userPRs.length <= 1;
          
          // Create appropriate comment
          let commentMessage = "";
          
          if (isFirstContribution) {
            commentMessage = `## üéâ Welcome to MyCSES, @${author}!\n\n`;
            commentMessage += "Thank you for your first contribution to our competitive programming solutions repository!\n\n";
          } else {
            commentMessage = `## üöÄ Thank you for contributing, @${author}!\n\n`;
          }
          
          commentMessage += "### üìä PR Analysis\n";
          commentMessage += `- **Labels Applied**: ${uniqueLabels.map(l => '`' + l + '`').join(', ')}\n`;
          commentMessage += `- **Files Changed**: ${changedFiles.length}\n`;
          commentMessage += `- **Category**: ${categoryDetected ? 'Auto-detected' : 'Please specify in description'}\n\n`;
          
          if (!hasProperDescription) {
            commentMessage += "### ‚ö†Ô∏è Template Usage\n";
            commentMessage += "It looks like this PR might not be using our template completely. Please ensure you:\n";
            commentMessage += "- Fill in the **Problem Name** and **CSES Link**\n";
            commentMessage += "- Describe your **Solution Approach** with complexity analysis\n";
            commentMessage += "- Complete the **Checklist** items\n\n";
            commentMessage += "You can edit your PR description to add this information.\n\n";
          }
          
          commentMessage += "### üéÉ Hacktoberfest Information\n";
          if (currentMonth === 10) {
            commentMessage += `This PR has been labeled for **Hacktoberfest ${currentYear}**! üéâ\n\n`;
          } else {
            commentMessage += "This PR has been labeled for **Hacktoberfest** participation year-round! üéâ\n\n";
          }
          
          commentMessage += "### üìã Next Steps\n";
          commentMessage += "1. Ensure your solution passes all CSES test cases\n";
          commentMessage += "2. Wait for maintainer review and address any requested changes\n";
          commentMessage += "3. Once approved and merged, you'll get the `hacktoberfest-accepted` label!\n\n";
          
          commentMessage += "Thank you for contributing to the competitive programming community! üöÄ";
          
          // Post the comment
          try {
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: commentMessage
            });
            
            console.log('‚úÖ Posted welcome/analysis comment');
          } catch (error) {
            console.error('‚ùå Error posting comment:', error);
          }

  issue-auto-label:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
    - name: Auto-label Issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.payload.issue.number;
          const issueTitle = context.payload.issue.title.toLowerCase();
          const issueBody = (context.payload.issue.body || '').toLowerCase();
          const combinedText = issueTitle + ' ' + issueBody;
          
          const labelsToAdd = ['hacktoberfest'];
          
          // Add current year label during October
          const now = new Date();
          if (now.getMonth() + 1 === 10) {
            labelsToAdd.push(`hacktoberfest_${now.getFullYear()}`);
          }
          
          // Auto-detect category and difficulty
          const categoryKeywords = {
            'introductory': 'category: introductory',
            'sorting': 'category: sorting-searching',
            'searching': 'category: sorting-searching',
            'dynamic programming': 'category: dp',
            'dp': 'category: dp',
            'mathematics': 'category: mathematics',
            'math': 'category: mathematics',
            'range': 'category: range-queries'
          };
          
          for (const [keyword, label] of Object.entries(categoryKeywords)) {
            if (combinedText.includes(keyword)) {
              labelsToAdd.push(label);
              break;
            }
          }
          
          // Difficulty detection
          if (combinedText.includes('easy') || combinedText.includes('beginner') || combinedText.includes('simple')) {
            labelsToAdd.push('easy');
            labelsToAdd.push('good first issue');
          } else if (combinedText.includes('hard') || combinedText.includes('difficult')) {
            labelsToAdd.push('hard');
            labelsToAdd.push('help wanted');
          } else if (combinedText.includes('medium')) {
            labelsToAdd.push('medium');
          }
          
          // Apply labels
          await github.rest.issues.addLabels({
            owner,
            repo,
            issue_number: issueNumber,
            labels: [...new Set(labelsToAdd)]
          });
          
          console.log(`‚úÖ Added labels to issue #${issueNumber}: ${labelsToAdd.join(', ')}`);

  pr-review-handler:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_review'
    
    steps:
    - name: Handle PR Review
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.pull_request.number;
          const reviewState = context.payload.review.state;
          
          if (reviewState === 'approved') {
            // Add hacktoberfest-accepted label
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: ['hacktoberfest-accepted']
            });
            
            // Post congratulatory comment
            const congratsMessage = "## üéâ Congratulations!\n\n" +
              "Your pull request has been **approved**! üöÄ\n\n" +
              "### üèÜ What This Means\n" +
              "- Your code meets our quality standards\n" +
              "- You've successfully contributed to the competitive programming community\n" +
              "- This PR now counts toward Hacktoberfest (when merged)!\n\n" +
              "### üîÑ Next Steps\n" +
              "- Your PR will be merged shortly\n" +
              "- Once merged, you'll get the `hacktoberfest-accepted` label\n" +
              "- Feel free to work on more problems!\n\n" +
              "Thank you for your valuable contribution! üåü";
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: congratsMessage
            });
            
            console.log(`‚úÖ Added approval labels and comment to PR #${prNumber}`);
          }