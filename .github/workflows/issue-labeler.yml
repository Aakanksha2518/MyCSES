name: Issue Labeler

on:
  issues:
    types: [opened, edited]

jobs:
  label-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Add labels to issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            
            const labels = [];
            
            // Add labels based on issue title/content
            if (title.includes('bug') || body.includes('bug')) {
              labels.push('bug');
            }
            
            if (title.includes('feature') || title.includes('enhancement') || body.includes('feature')) {
              labels.push('enhancement');
            }
            
            if (title.includes('documentation') || title.includes('docs') || body.includes('documentation')) {
              labels.push('documentation');
            }
            
            if (title.includes('help') || title.includes('question') || body.includes('help')) {
              labels.push('question');
            }
            
            if (title.includes('good first issue') || body.includes('good first issue')) {
              labels.push('good first issue');
            }
            
            // Add difficulty labels based on content
            if (title.includes('easy') || body.includes('easy')) {
              labels.push('difficulty: easy');
            } else if (title.includes('medium') || body.includes('medium')) {
              labels.push('difficulty: medium');
            } else if (title.includes('hard') || body.includes('hard')) {
              labels.push('difficulty: hard');
            }
            
            // Add problem category labels for competitive programming
            if (title.includes('dp') || title.includes('dynamic programming') || body.includes('dynamic programming')) {
              labels.push('dynamic-programming');
            }
            
            if (title.includes('graph') || body.includes('graph')) {
              labels.push('graph');
            }
            
            if (title.includes('sorting') || title.includes('searching') || body.includes('sorting') || body.includes('searching')) {
              labels.push('sorting-searching');
            }
            
            if (title.includes('math') || title.includes('mathematics') || body.includes('mathematics')) {
              labels.push('mathematics');
            }
            
            if (title.includes('range queries') || body.includes('range queries')) {
              labels.push('range-queries');
            }
            
            // Add priority labels
            if (title.includes('urgent') || title.includes('critical') || body.includes('urgent')) {
              labels.push('priority: high');
            } else if (title.includes('low priority') || body.includes('low priority')) {
              labels.push('priority: low');
            } else {
              labels.push('priority: medium');
            }
            
            // Add default label if no specific labels were found
            if (labels.length === 0) {
              labels.push('needs-triage');
            }
            
            // Apply labels to the issue
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
              
              console.log(`Added labels: ${labels.join(', ')} to issue #${issue.number}`);
            }