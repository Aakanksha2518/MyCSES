name: Auto-label Issues and PRs

on:
  issues:
    types: [opened]
  pull_request:
    types: [opened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  auto-label:
    runs-on: ubuntu-latest
    
    steps:
    - name: Add Hacktoberfest labels to issues
      if: github.event_name == 'issues'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          // Get current date to check if we're in October
          const now = new Date();
          const currentMonth = now.getMonth() + 1; // getMonth() returns 0-11
          const currentYear = now.getFullYear();
          
          // Add hacktoberfest label during October or if it's Hacktoberfest season
          const isHacktoberfestSeason = currentMonth === 10;
          
          // Always add hacktoberfest labels since this repo participates year-round
          const labelsToAdd = ['hacktoberfest'];
          
          // Add additional labels based on issue content or during Hacktoberfest season
          if (isHacktoberfestSeason) {
            labelsToAdd.push(`hacktoberfest_${currentYear}`);
          }
          
          // Check issue title and body for keywords to determine difficulty
          const issueTitle = context.payload.issue.title.toLowerCase();
          const issueBody = (context.payload.issue.body || '').toLowerCase();
          const combinedText = issueTitle + ' ' + issueBody;
          
          // Auto-add 'good first issue' for beginner-friendly problems
          const beginnerKeywords = [
            'introductory', 'basic', 'easy', 'beginner', 'simple', 'hello world',
            'missing number', 'weird algorithm', 'repetitions', 'increasing array'
          ];
          
          if (beginnerKeywords.some(keyword => combinedText.includes(keyword))) {
            labelsToAdd.push('good first issue');
          }
          
          // Auto-add 'help wanted' for complex problems
          const complexKeywords = [
            'hard', 'difficult', 'complex', 'advanced', 'optimization needed',
            'graph', 'tree', 'geometry', 'string algorithm'
          ];
          
          if (complexKeywords.some(keyword => combinedText.includes(keyword))) {
            labelsToAdd.push('help wanted');
          }
          
          // Add category-specific labels
          const categoryMap = {
            'introductory': 'category: introductory',
            'sorting': 'category: sorting-searching',
            'searching': 'category: sorting-searching',
            'dynamic programming': 'category: dp',
            'dp': 'category: dp',
            'graph': 'category: graph',
            'tree': 'category: tree',
            'mathematics': 'category: mathematics',
            'math': 'category: mathematics',
            'string': 'category: string',
            'geometry': 'category: geometry'
          };
          
          for (const [keyword, label] of Object.entries(categoryMap)) {
            if (combinedText.includes(keyword)) {
              labelsToAdd.push(label);
              break; // Only add one category label
            }
          }
          
          // Add the labels to the issue
          try {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: labelsToAdd
            });
            
            console.log(`Added labels: ${labelsToAdd.join(', ')}`);
          } catch (error) {
            console.error('Error adding labels:', error);
          }

    - name: Add Hacktoberfest labels to PRs
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          // Get current date to check if we're in October
          const now = new Date();
          const currentMonth = now.getMonth() + 1;
          const currentYear = now.getFullYear();
          
          const isHacktoberfestSeason = currentMonth === 10;
          
          // Labels to add to PRs
          const labelsToAdd = ['hacktoberfest'];
          
          if (isHacktoberfestSeason) {
            labelsToAdd.push(`hacktoberfest_${currentYear}`);
          }
          
          // Check PR title and body for type of contribution
          const prTitle = context.payload.pull_request.title.toLowerCase();
          const prBody = (context.payload.pull_request.body || '').toLowerCase();
          const combinedText = prTitle + ' ' + prBody;
          
          // Auto-add 'good first issue' for beginner-friendly problems
          const beginnerKeywords = [
            'introductory', 'basic', 'easy', 'beginner', 'simple', 'hello world',
            'missing number', 'weird algorithm', 'repetitions', 'increasing array'
          ];
          
          if (beginnerKeywords.some(keyword => combinedText.includes(keyword))) {
            labelsToAdd.push('good first issue');
          }
          
          // Auto-add 'help wanted' for complex problems
          const complexKeywords = [
            'hard', 'difficult', 'complex', 'advanced', 'optimization needed',
            'graph', 'tree', 'geometry', 'string algorithm'
          ];
          
          if (complexKeywords.some(keyword => combinedText.includes(keyword))) {
            labelsToAdd.push('help wanted');
          }
          
          // Add difficulty labels based on problem complexity
          const difficultyKeywords = {
            'easy': ['easy', 'simple', 'basic', 'introductory', 'beginner'],
            'medium': ['medium', 'intermediate', 'moderate'],
            'hard': ['hard', 'difficult', 'complex', 'advanced', 'challenging']
          };
          
          for (const [difficulty, keywords] of Object.entries(difficultyKeywords)) {
            if (keywords.some(keyword => combinedText.includes(keyword))) {
              labelsToAdd.push(`difficulty: ${difficulty}`);
              break; // Only add one difficulty label
            }
          }
          
          // Determine PR type and add appropriate labels
          if (combinedText.includes('bug') || combinedText.includes('fix')) {
            labelsToAdd.push('bug');
          } else if (combinedText.includes('new') || combinedText.includes('add solution')) {
            labelsToAdd.push('enhancement');
          } else if (combinedText.includes('documentation') || combinedText.includes('readme')) {
            labelsToAdd.push('documentation');
          }
          
          // Add category-specific labels based on CSES structure
          const categoryMap = {
            'introductory': 'category: introductory',
            'sorting': 'category: sorting-searching',
            'searching': 'category: sorting-searching',
            'dynamic programming': 'category: dp',
            'dp': 'category: dp',
            'graph': 'category: graph',
            'tree': 'category: tree',
            'mathematics': 'category: mathematics',
            'math': 'category: mathematics',
            'string': 'category: string',
            'geometry': 'category: geometry',
            'range queries': 'category: range-queries',
            'range query': 'category: range-queries'
          };
          
          // Check for keywords in PR title/body first
          for (const [keyword, label] of Object.entries(categoryMap)) {
            if (combinedText.includes(keyword)) {
              labelsToAdd.push(label);
              break; // Only add one category label
            }
          }
          
          // Also try to detect category from changed files paths
          const files = context.payload.pull_request.changed_files || [];
          let categoryDetected = labelsToAdd.some(label => label.startsWith('category:'));
          for (const file of files) {
            if (file && file.filename && !categoryDetected) {
              const filePath = file.filename.toLowerCase();
              if (filePath.includes('1_introductory_problems/')) {
                labelsToAdd.push('category: introductory');
                categoryDetected = true;
              } else if (filePath.includes('2_sorting_searching/')) {
                labelsToAdd.push('category: sorting-searching');
                categoryDetected = true;
              } else if (filePath.includes('3_dp/')) {
                labelsToAdd.push('category: dp');
                categoryDetected = true;
              } else if (filePath.includes('5_range_queries/')) {
                labelsToAdd.push('category: range-queries');
                categoryDetected = true;
              } else if (filePath.includes('7_mathematics/')) {
                labelsToAdd.push('category: mathematics');
                categoryDetected = true;
              }
            }
          }
          
          try {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: labelsToAdd
            });
            
            console.log(`Added labels to PR: ${labelsToAdd.join(', ')}`);
          } catch (error) {
            console.error('Error adding labels to PR:', error);
          }